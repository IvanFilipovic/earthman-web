import{defineComponent as e,computed as a,h as t,onServerPrefetch as n,toValue as r,getCurrentInstance as s,ref as o,shallowRef as u,toRef as i,nextTick as l,unref as c}from"vue";import{Icon as d,getIcon as m,loadIcon as p}from"@iconify/vue";import{getIconCSS as v}from"@iconify/utils/lib/css/icon";import{k as f,x as y,e as _,u as h,t as D,v as g}from"./server.mjs";import"../nitro/nitro.mjs";import"node:http";import"node:https";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"node:crypto";import"@intlify/utils";import"vue-router";import"@iconify/utils";import"consola";import"node:url";import"ipx";import"pinia";import"vue/server-renderer";import"../routes/renderer.mjs";import"vue-bundle-renderer/runtime";import"unhead/server";import"devalue";import"unhead/utils";import"unhead/plugins";const w={trailing:!0};function debounce(e,a=25,t={}){if(t={...w,...t},!Number.isFinite(a))throw new TypeError("Expected `wait` to be a finite number");let n,r,s,o,u=[];const applyFn=(a,n)=>(s=async function(e,a,t){return await e.apply(a,t)}(e,a,n),s.finally(()=>{if(s=null,t.trailing&&o&&!r){const e=applyFn(a,o);return o=null,e}}),s),debounced=function(...e){return t.trailing&&(o=e),s||new Promise(s=>{const i=!r&&t.leading;clearTimeout(r),r=setTimeout(()=>{r=null;const a=t.leading?n:applyFn(this,e);o=null;for(const e of u)e(a);u=[]},a),i?(n=applyFn(this,e),s(n)):u.push(s)})},_clearTimeout=e=>{e&&(clearTimeout(e),r=null)};return debounced.isPending=()=>!!r,debounced.cancel=()=>{_clearTimeout(r),u=[],o=null},debounced.flush=()=>{if(_clearTimeout(r),!o||s)return;const e=o;return o=null,applyFn(this,e)},debounced}function useAsyncData(...e){var t;const d="string"==typeof e[e.length-1]?e.pop():void 0;(function(e,a){if("string"==typeof e)return!1;if("object"==typeof e&&null!==e)return!1;if("function"==typeof e&&"function"==typeof a)return!1;return!0})(e[0],e[1])&&e.unshift(d);let[m,p,v={}]=e;const y=a(()=>r(m));if("string"!=typeof y.value)throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if("function"!=typeof p)throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const _=f();null!=v.server||(v.server=!0),null!=v.default||(v.default=getDefault),null!=v.getCachedData||(v.getCachedData=getDefaultCachedData),null!=v.lazy||(v.lazy=!1),null!=v.immediate||(v.immediate=!0),null!=v.deep||(v.deep=D.deep),null!=v.dedupe||(v.dedupe="cancel"),v._functionName,_._asyncData[y.value];const h={cause:"initial",dedupe:v.dedupe};(null==(t=_._asyncData[y.value])?void 0:t._init)||(h.cachedData=v.getCachedData(y.value,_,{cause:"initial"}),_._asyncData[y.value]=function(e,a,t,n,r){var s;null!=(s=e.payload._errors)[a]||(s[a]=D.errorValue);const d=n.getCachedData!==getDefaultCachedData,m=t,p=n.deep?o:u,v=null!=r,f=e.hook("app:data:refresh",async e=>{e&&!e.includes(a)||await y.execute({cause:"refresh:hook"})}),y={data:p(v?r:n.default()),pending:u(!v),error:i(e.payload._errors,a),status:u("idle"),execute:(...t)=>{var r,s;const[o,u]=t,i=o&&void 0===u&&"object"==typeof o?o:{};if(e._asyncDataPromises[a]){if("defer"===(l=null!=(r=i.dedupe)?r:n.dedupe)||!1===l)return e._asyncDataPromises[a];e._asyncDataPromises[a].cancelled=!0}var l;if("initial"===i.cause||e.isHydrating){const t="cachedData"in i?i.cachedData:n.getCachedData(a,e,{cause:null!=(s=i.cause)?s:"refresh:manual"});if(null!=t)return e.payload.data[a]=y.data.value=t,y.error.value=D.errorValue,y.status.value="success",Promise.resolve(t)}y.pending.value=!0,y.status.value="pending";const d=new Promise((a,t)=>{try{a(m(e))}catch(e){t(e)}}).then(async t=>{if(d.cancelled)return e._asyncDataPromises[a];let r=t;n.transform&&(r=await n.transform(t)),n.pick&&(r=function(e,a){const t={};for(const n of a)t[n]=e[n];return t}(r,n.pick)),e.payload.data[a]=r,y.data.value=r,y.error.value=D.errorValue,y.status.value="success"}).catch(t=>{if(d.cancelled)return e._asyncDataPromises[a];y.error.value=g(t),y.data.value=c(n.default()),y.status.value="error"}).finally(()=>{d.cancelled||(y.pending.value=!1,delete e._asyncDataPromises[a])});return e._asyncDataPromises[a]=d,e._asyncDataPromises[a]},_execute:debounce((...e)=>y.execute(...e),0,{leading:!0}),_default:n.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{var t;f(),(null==(t=e._asyncData[a])?void 0:t._init)&&(e._asyncData[a]._init=!1),d||l(()=>{var t;(null==(t=e._asyncData[a])?void 0:t._init)||(clearNuxtDataByKey(e,a),y.execute=()=>Promise.resolve(),y.data.value=D.value)})}};return y}(_,y.value,p,v,h.cachedData));_._asyncData[y.value]._deps++;if(!1!==v.server&&_.payload.serverRendered&&v.immediate){const e=_._asyncData[y.value].execute(h);s()?n(()=>e):_.hook("app:created",async()=>{await e})}const w={data:writableComputedRef(()=>{var e;return null==(e=_._asyncData[y.value])?void 0:e.data}),pending:writableComputedRef(()=>{var e;return null==(e=_._asyncData[y.value])?void 0:e.pending}),status:writableComputedRef(()=>{var e;return null==(e=_._asyncData[y.value])?void 0:e.status}),error:writableComputedRef(()=>{var e;return null==(e=_._asyncData[y.value])?void 0:e.error}),refresh:(...e)=>_._asyncData[y.value].execute(...e),execute:(...e)=>_._asyncData[y.value].execute(...e),clear:()=>clearNuxtDataByKey(_,y.value)},x=Promise.resolve(_._asyncDataPromises[y.value]).then(()=>w);return Object.assign(x,w),x}function writableComputedRef(e){return a({get(){var a;return null==(a=e())?void 0:a.value},set(a){const t=e();t&&(t.value=a)}})}function clearNuxtDataByKey(e,a){a in e.payload.data&&(e.payload.data[a]=void 0),a in e.payload._errors&&(e.payload._errors[a]=D.errorValue),e._asyncData[a]&&(e._asyncData[a].data.value=void 0,e._asyncData[a].error.value=D.errorValue,e._asyncData[a].pending.value=!1,e._asyncData[a].status.value="idle"),a in e._asyncDataPromises&&(e._asyncDataPromises[a]&&(e._asyncDataPromises[a].cancelled=!0),e._asyncDataPromises[a]=void 0)}const getDefault=()=>D.value,getDefaultCachedData=(e,a,t)=>a.isHydrating?a.payload.data[e]:"refresh:manual"!==t.cause&&"refresh:hook"!==t.cause?a.static.data[e]:void 0;async function loadIcon(e,a){if(!e)return null;const t=m(e);if(t)return t;let n;const r=p(e).catch(()=>(console.warn(`[Icon] failed to load icon \`${e}\``),null));return a>0?await Promise.race([r,new Promise(t=>{n=setTimeout(()=>{console.warn(`[Icon] loading icon \`${e}\` timed out after ${a}ms`),t()},a)})]).finally(()=>clearTimeout(n)):await r,m(e)}function useResolvedName(e){const t=y().icon,n=(t.collections||[]).sort((e,a)=>a.length-e.length);return a(()=>{var a;const r=e(),s=r.startsWith(t.cssSelectorPrefix)?r.slice(t.cssSelectorPrefix.length):r,o=(null==(a=t.aliases)?void 0:a[s])||s;if(!o.includes(":")){const e=n.find(e=>o.startsWith(e+"-"));return e?e+":"+o.slice(e.length+1):o}return o})}function resolveCustomizeFn(e,a){if(!1!==e)return!0===e||null===e?a:e}const x="NUXT_ICONS_SERVER_CSS";const P=e({name:"NuxtIconCss",props:{name:{type:String,required:!0},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(e){const r=f(),s=y().icon,o=a(()=>e.name?s.cssSelectorPrefix+e.name:""),u=a(()=>"."+function(e){return e.replace(/([^\w-])/g,"\\$1")}(o.value));return n(async()=>{var a;{const t=_().icon||{};if(!(null==(a=null==t?void 0:t.serverKnownCssClasses)?void 0:a.includes(o.value))){const a=await loadIcon(e.name,s.fetchTimeout).catch(()=>null);if(!a)return null;let t=r.vueApp._context.provides[x];if(t||(t=r.vueApp._context.provides[x]=new Map,r.runWithContext(()=>{h({style:[()=>{let e=Array.from(t.values()).sort().join("");return s.cssLayer&&(e=`@layer ${s.cssLayer} {${e}}`),{innerHTML:e}}]},{tagPriority:"low"})})),e.name&&!t.has(e.name)){const n=function(a,t=!0){let n=u.value;s.cssWherePseudo&&(n=`:where(${n})`);const r=v(a,{iconSelector:n,format:"compressed",customise:resolveCustomizeFn(e.customize,s.customize)});return s.cssLayer&&t?`@layer ${s.cssLayer} { ${r} }`:r}(a,!1);t.set(e.name,n)}return null}}}),()=>t("span",{class:["iconify",o.value]})}}),b=e({name:"NuxtIconSvg",props:{name:{type:String,required:!0},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(e,{slots:a}){f();const r=y().icon,s=useResolvedName(()=>e.name),o="i-"+s.value;return s.value&&n(async()=>{await useAsyncData(o,async()=>await loadIcon(s.value,r.fetchTimeout),{deep:!1})}),()=>t(d,{icon:s.value,ssr:!0,customise:resolveCustomizeFn(e.customize,r.customize)},a)}}),z=e({name:"NuxtIcon",props:{name:{type:String,required:!0},mode:{type:String,required:!1,default:null},size:{type:[Number,String],required:!1,default:null},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(e,{slots:n}){const r=f(),s=y().icon,o=useResolvedName(()=>e.name),u=a(()=>{var a;return(null==(a=r.vueApp)?void 0:a.component(o.value))||("svg"===(e.mode||s.mode)?b:P)}),i=a(()=>{const a=e.size||s.size;return a?{fontSize:Number.isNaN(+a)?a:a+"px"}:null});return()=>t(u.value,{...s.attrs,name:o.value,class:s.class,style:i.value,customize:e.customize},n)}}),C=Object.freeze(Object.defineProperty({__proto__:null,default:z},Symbol.toStringTag,{value:"Module"}));export{z as _,C as i,useAsyncData as u};
//# sourceMappingURL=index-Ccr6sSLn.mjs.map
