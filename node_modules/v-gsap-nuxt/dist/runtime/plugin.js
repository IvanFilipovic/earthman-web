import Draggable from "gsap/Draggable";
import { ScrollTrigger, ScrollToPlugin } from "gsap/all";
import { gsap } from "gsap";
import TextPlugin from "gsap/TextPlugin";
import { nextTick } from "vue";
import { uuidv4 } from "./utils/utils.js";
import { entrancePresets } from "./utils/entrance-presets.js";
gsap.registerPlugin(ScrollTrigger, ScrollToPlugin, Draggable, TextPlugin);
const globalTimelines = {};
let observer;
let intersectionObserver;
export const vGsapDirective = (appType, configOptions, gsapContext, resizeListener) => ({
  getSSRProps: (binding) => {
    binding = loadPreset(binding, configOptions);
    return {
      "data-vgsap-from-invisible": binding.modifiers.fromInvisible,
      "data-vgsap-stagger": binding.modifiers.stagger
    };
  },
  async beforeMount(el, binding, vnode) {
    binding = loadPreset(binding, configOptions);
    el.dataset.gsapId = uuidv4();
    el.dataset.vgsapFromInvisible = binding.modifiers.fromInvisible;
    el.dataset.vgsapStagger = binding.modifiers.stagger;
    if (!gsapContext) gsapContext = gsap.context(() => {
    });
    if (binding.modifiers.timeline) {
      assignChildrenOrderAttributesFor(vnode);
      await nextTick();
      globalTimelines[el.dataset.gsapId] = prepareTimeline(
        el,
        binding,
        configOptions
      );
      el.dataset.gsapTimeline = true;
      gsapContext.add(() => globalTimelines[el.dataset.gsapId]);
    }
  },
  mounted(el, binding) {
    let timeline;
    const mm = gsap.matchMedia();
    if (binding.modifiers.timeline) {
      globalTimelines[el.dataset.gsapId]?.scrollTrigger?.refresh();
      ScrollTrigger?.normalizeScroll(true);
    } else {
      if (binding.modifiers.magnetic) return addMagneticEffect(el, binding);
      const breakpoint = configOptions?.breakpoint || 768;
      if (binding.modifiers.desktop) {
        mm.add(`(min-width: ${breakpoint}px)`, () => {
          timeline = prepareTimeline(el, binding, configOptions);
        });
      } else if (binding.modifiers.mobile) {
        mm.add(`(max-width: ${breakpoint}px)`, () => {
          timeline = prepareTimeline(el, binding, configOptions);
        });
      } else {
        timeline = prepareTimeline(el, binding, configOptions);
      }
      if (binding.modifiers.add) {
        let order = getValueFromModifier(binding, "order-") || getValueFromModifier(binding, "suggestedOrder-");
        if (binding.modifiers.withPrevious) order = "<";
        if (!el.closest(`[data-gsap-timeline="true"]`)?.dataset?.gsapId) return;
        globalTimelines[el.closest(`[data-gsap-timeline="true"]`).dataset.gsapId]?.add(timeline, order);
      }
    }
    gsapContext.add(() => timeline);
    resizeListener = window.addEventListener("resize", () => {
      ScrollTrigger?.refresh(true);
    });
  },
  unmounted(el) {
    ScrollTrigger.getById(el.dataset.gsapId)?.kill();
    globalTimelines[el.dataset.gsapId]?.scrollTrigger?.kill();
    gsapContext.revert();
    removeEventListener("resize", resizeListener);
    if (observer) observer.disconnect();
    if (intersectionObserver) intersectionObserver.disconnect();
  }
});
function assignChildrenOrderAttributesFor(vnode, startOrder) {
  let order = startOrder || 0;
  const getChildren = (vnode2) => {
    if (vnode2?.children) return Array.from(vnode2?.children);
    if (vnode2?.component?.subtree) return Array.from(vnode2?.ctx?.subtree);
    return [];
  };
  (getChildren(vnode) || [])?.forEach((child) => {
    ;
    (child?.dirs ? Array.from(child?.dirs) : [])?.forEach((dir) => {
      if (dir.modifiers.timeline) return;
      dir.modifiers[`suggestedOrder-${order}`] = true;
      order++;
    });
    order = assignChildrenOrderAttributesFor(child, order);
  });
  return order;
}
function prepareTimeline(el, binding, configOptions) {
  const timelineOptions = {};
  const callbacks = prepareCallbacks(binding);
  const once = binding.modifiers.call ?? binding.modifiers.once;
  const scroller = configOptions?.scroller || binding.value?.scroller || binding.value?.[0]?.scroller || binding.value?.[1]?.scroller || void 0;
  const scrub = binding.value?.scrub ?? binding.value?.[1]?.scrub ?? (once == true ? false : void 0) ?? true;
  const markers = binding.modifiers.markers;
  if (binding.modifiers.whenVisible) {
    timelineOptions.scrollTrigger = {
      trigger: el,
      id: el.dataset.gsapId,
      start: binding.value?.start ?? "top 90%",
      end: binding.value?.end ?? "top 50%",
      scroller,
      scrub,
      ...callbacks,
      markers,
      toggleActions: binding.modifiers.once ? binding.modifiers.reversible ? "play none none reverse" : "play none none none" : void 0
    };
  }
  if (binding.modifiers.pinned) {
    const end = binding.value?.end ?? "+=1000px";
    timelineOptions.scrollTrigger = {
      trigger: el,
      id: el.dataset.gsapId,
      start: binding.value?.start ?? "center center",
      end,
      scroller,
      scrub,
      pin: true,
      pinSpacing: "margin",
      ...callbacks,
      markers
    };
  }
  if (binding.modifiers.parallax) {
    timelineOptions.scrollTrigger = {
      trigger: el,
      id: el.dataset.gsapId,
      start: `top bottom`,
      end: `bottom top`,
      scroller,
      scrub: true,
      ...callbacks,
      markers
    };
  }
  if (!once && binding.modifiers.parallax)
    timelineOptions.scrollTrigger.toggleActions = "restart none none reverse";
  if (binding.modifiers.infinitely) timelineOptions.repeat = -1;
  const timeline = gsap.timeline(timelineOptions);
  if (binding.modifiers.parallax) {
    const [parallaxType, parallaxFactor] = Object.keys(binding.modifiers).find((m) => m.includes("slower") || m.includes("faster"))?.split("-");
    const direction = parallaxType == "slower" ? -1 : 1;
    timeline.fromTo(
      el,
      { yPercent: +`${10 * +(parallaxFactor || 5) * direction}` },
      {
        yPercent: +`${10 * +(parallaxFactor || 5) * direction * -1}`,
        ease: "linear"
      }
    );
  }
  const delayKey = Object.keys(binding.modifiers).find(
    (modifier) => modifier.includes("delay")
  );
  if (delayKey) {
    const milliseconds = delayKey.split("-")?.[1] || 500;
    timeline.to("body", { duration: +milliseconds / 1e3 });
  }
  const stagger = binding.modifiers.stagger ? binding.value?.stagger ?? binding.value?.[1]?.stagger ?? "0.2" : false;
  if (binding.modifiers.stagger) el = el.children;
  delete binding.value?.start;
  delete binding.value?.end;
  delete binding.value?.scrub;
  delete binding.value?.scroller;
  delete binding.value?.markers;
  delete binding.value?.toggleActions;
  const animationType = Object.keys(binding.modifiers).find(
    (modifier) => ["to", "from", "set", "fromTo", "call"].includes(modifier)
  );
  if (animationType == "to") {
    if (binding.modifiers.fromInvisible)
      binding.value.opacity = binding.value.opacity || 1;
    timeline.to(el, { ...binding.value, stagger });
  }
  if (animationType == "set") timeline.set(el, { ...binding.value, stagger });
  if (animationType == "from") {
    timeline.from(el, {
      ...binding.value,
      stagger,
      opacity: binding.value.opacity ?? (binding.modifiers.fromInvisible ? 0 : 1),
      duration: binding.value.duration || 0.5
    });
    if (binding.modifiers.fromInvisible)
      timeline.to(
        el,
        { opacity: 1, stagger, duration: binding.value.duration || 0.5 },
        "<"
      );
  }
  if (animationType == "fromTo") {
    const values = binding.value;
    if (binding.modifiers.stagger) values[1].stagger = stagger;
    if (binding.modifiers.fromInvisible) {
      values[0].opacity = 0;
      values[1].opacity = values[1].opacity || 1;
    }
    timeline.fromTo(el, binding.value?.[0], binding.value?.[1]);
  }
  if (binding.modifiers.animateText) {
    const value = typeof binding.value === "string" ? binding.value : binding.value?.text || el.textContent;
    if (el.textContent) el.textContent = "";
    const speeds = {
      slow: 0.5,
      fast: 10
    };
    const speed = speeds[Object.keys(binding.modifiers).find(
      (modifier) => Object.keys(speeds).includes(modifier)
    ) || ""] || 2;
    timeline.to(el, { text: { value, speed } });
  }
  if (binding.modifiers.whileHover) {
    timeline.pause();
    el.addEventListener("mouseenter", () => timeline.play());
    el.addEventListener("mouseout", () => {
      if (binding.modifiers.noReverse) timeline.time(0).pause();
      else timeline.play().reverse();
    });
  }
  if (animationType == "call") {
    timeline.call(binding.value);
  }
  if (binding.modifiers.draggable) {
    const type = Object.keys(binding.modifiers).find(
      (modifier) => ["x", "y", "rotation"].includes(modifier)
    );
    Draggable.create(el, {
      type,
      bounds: binding.value || el.parentElement
    });
  }
  if (getValueFromModifier(binding, "onState")) {
    const [dataKey, targetValue = "true"] = Object.keys(binding.modifiers).find((m) => m.toLowerCase().includes("onstate"))?.split("-")?.slice(1);
    const targetElement = binding.modifiers.inherit ? (el?.[0] || el).closest(`*[data-${dataKey}]`) : el?.[0] || el;
    const getCurrentValue = () => targetElement.dataset[dataKey];
    if (getCurrentValue() != targetValue) timeline.pause();
    observer = new MutationObserver((mutationRecords) => {
      const event = mutationRecords.filter(
        (record) => record.attributeName == `data-${dataKey}`
      )?.[0];
      if (!event) return;
      if (getCurrentValue() == targetValue) return timeline.play();
      else return timeline.play().reverse();
    });
    observer.observe(targetElement, { attributes: true });
  }
  return timeline;
}
function prepareCallbacks(binding) {
  const callbacks = {};
  if (binding.modifiers.onUpdate) callbacks.onUpdate = binding.value;
  if (binding.modifiers.onEnter) callbacks.onEnter = binding.value;
  if (binding.modifiers.onEnterBack) callbacks.onEnterBack = binding.value;
  if (binding.modifiers.onLeave) callbacks.onLeave = binding.value;
  if (binding.modifiers.onLeaveBack) callbacks.onLeaveBack = binding.value;
  return callbacks;
}
function addMagneticEffect(el, binding) {
  const strengthModifiers = {
    strong: 2,
    stronger: 1.5,
    weaker: 0.75,
    weak: 0.5
  };
  const handleMouseMove = (e) => {
    if (el) {
      const { width, height, left, right, top, bottom } = el.getBoundingClientRect();
      const centerX = left + width / 2;
      const centerY = top + height / 2;
      const deltaX = e.clientX - centerX;
      const deltaY = e.clientY - centerY;
      const distanceX = left < e.clientX && right > e.clientX ? 0 : Math.min(Math.abs(e.clientX - left), Math.abs(e.clientX - right));
      const distanceY = top < e.clientY && bottom > e.clientY ? 0 : Math.min(Math.abs(e.clientY - top), Math.abs(e.clientY - bottom));
      const strengthFactor = Object.entries(strengthModifiers).find(
        (entry) => binding.modifiers[entry[0]]
      )?.[1] || 1;
      const distance = Math.sqrt(distanceX ** 2 + distanceY ** 2);
      const centerDistance = Math.sqrt(deltaX ** 2 + deltaY ** 2);
      const magneticDistanceX = width / 3;
      const magneticDistanceY = height / 3;
      const attractionStrength = 0.45 * strengthFactor;
      if (distance < magneticDistanceX && distance < magneticDistanceY) {
        const strength = Math.abs(1 - centerDistance / 4) / ((magneticDistanceX + magneticDistanceY) / 2);
        gsap.to(el, {
          x: deltaX * strength * attractionStrength,
          y: deltaY * strength * attractionStrength,
          duration: 0.2
        });
      } else {
        gsap.to(el, {
          x: 0,
          y: 0,
          duration: 0.3
        });
      }
    }
  };
  intersectionObserver = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        window.addEventListener("mousemove", handleMouseMove);
      } else {
        window.removeEventListener("mousemove", handleMouseMove);
      }
    });
  });
  intersectionObserver.observe(el);
}
function loadPreset(binding, configOptions) {
  const applyPreset = (preset, binding2) => {
    preset.modifiers.split(".").forEach((modifier) => binding2.modifiers[modifier] = true);
    if (typeof binding2.value == "string") binding2.value = {};
    if (preset.value) {
      if (binding2.modifiers.fromTo) {
        binding2.value = [
          preset.value[0],
          { ...preset.value[1], ...binding2.value }
        ];
      } else binding2.value = { ...preset.value, ...binding2.value };
    }
  };
  if (binding.modifiers.preset && !!configOptions?.presets?.length) {
    const preset = configOptions?.presets.find(
      (preset2) => preset2.name == binding.value
    );
    if (preset) applyPreset(preset, binding);
  }
  if (binding.modifiers.entrance) {
    const preset = entrancePresets.filter(
      (preset2) => Object.keys(binding.modifiers).includes(preset2.name)
    )?.[0];
    if (preset) applyPreset(preset, binding);
  }
  return binding;
}
function resetAndKillTimeline(timeline) {
  timeline?.restart(false, true);
  timeline?.kill();
  return void 0;
}
function getValueFromModifier(binding, term) {
  return Object.keys(binding.modifiers)?.find((m) => m.toLowerCase().includes(term.toLowerCase()))?.split("-")?.[1];
}
export const useGSAP = () => {
  return gsap;
};
